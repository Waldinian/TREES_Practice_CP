substr(TIMESTAMP_START, 9, 10), ":",
substr(TIMESTAMP_START, 11, 12), ":",
"00",
sep = ""))) %>%  # convert from yyymmddhhmmss to yyyy-mm-dd hh:mm:ss format
mutate_at(names(Flux.raw[, -length(names(Flux.raw))]), as.numeric)  # convert everything but timestamp to numeric
# now merge them all together
Combine <- function(A.raw, B.raw){
full.raw.long <- full_join(by = "TIMESTAMP", A.raw, B.raw) # keep all values
}
All_Data.raw <- Combine(Combine(Combine(SoilHF.raw, Precip.raw), Met.raw), Flux.raw)
# test plots for QA/QC
SoilTest.Plot <- ggplot(data = All_Data.raw, size=0.01) +
geom_line(mapping = aes(x=TIMESTAMP, y=SoilT_PitA_5_Avg,), color='blue')+
geom_line(mapping = aes(x=TIMESTAMP, y=SoilT_PitA_15_Avg), color='red')
# SoilTest.Plot
PrecipTest.Plot <- ggplot(data = All_Data.raw)+
geom_col(mapping=aes(x=TIMESTAMP, y=Rain_mm_Tot))
# PrecipTest.Plot
MetTest.Plot <- ggplot(data = All_Data.raw)+
geom_point(mapping = aes(x=TIMESTAMP, y=AirT_6m_Avg), size = 0.5)
# MetTest.Plot
CO2Test.Plot <- ggplot(data = All_Data.raw)+
geom_point(mapping = aes(x=TIMESTAMP, y=CO2_1_1_1), size = 0.5)
# CO2Test.Plot
###########################################
# Comments:
# * there's a day in april or may with a massive (erroneous) spike in precip
# * probably because of melt.
# * only look at precip data after spring melt.
# * need to start in may anyway, because that's when the met data starts
# * looks like the IRGA was calibrated in july 2019 and december 2018, but I'll deal with that later
###########################################
# To create the driver file, I'm going to duplicate the weather2013part.csv format,
# then feed that file into the create_driver_file.R script
# Weather2013Part.csv columns:
Year = year(All_Data.raw$TIMESTAMP)
DOY = yday(All_Data.raw$TIMESTAMP)
TIMESTAMP = All_Data.raw$TIMESTAMP
AirTemp_C <- All_Data.raw$T_SONIC_1_1_1
AirTemp.Plot <- ggplot() + geom_line(mapping = aes(x=TIMESTAMP, y=AirTemp_C))
# AirTemp.Plot
RH_fraction <- All_Data.raw$RH_1_1_1/100
Vap_Press_kPa <- RH_fraction*0.6108*exp(17.27*T/(T + 237.3))
Vap_Press.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=Vap_Press_kPa), size = 0.1)
# Vap_Press.Plot
Qpar <- All_Data.raw$PAR_dn_Avg  # incoming PAR
Qpar.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=Qpar), size=0.1)
# Qpar.Plot
WindSpeed_m_s <- All_Data.raw$WS_1_1_1
WS.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=WindSpeed_m_s), size = 0.1)
# WS.Plot
WindDir_Deg <- All_Data.raw$WD_1_1_1
WD.Plot <- ggplot() +
geom_point(aes(x = WindSpeed_m_s, y = WindDir_Deg, color = hour(TIMESTAMP)), size = 0.8, alpha = 0.05) +
coord_polar(theta = "y") +
scale_color_continuous(low="blue", high="red")
WD.Plot  # very cool plot
Rain_Tot <- All_Data.raw$Rain_mm_Tot
SoilTemp_5cm_C <- All_Data.raw %>%
pivot_longer(-TIMESTAMP, names_to = "pit", values_to = "temp") %>%  # longify
filter(pit == "SoilT_PitA_5_Avg" |
pit == "SoilT_PitB_5_Avg" |
pit == "SoilT_PitC_5_Avg" |
pit == "SoilT_PitD_5_Avg") %>%   # want the 5cm soil pits
group_by(TIMESTAMP) %>%  # so that we can average all four soil pits in one timestamp
summarize(temp = mean(temp, na.rm = TRUE))  # take the mean of all four soil pits at one timestamp
SoilTemp_5cm_C <- SoilTemp_5cm_C$temp
Soil5.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=SoilTemp_5cm_C), size = 0.1)
# Soil5.Plot
SoilTemp_15cm_C <- All_Data.raw %>%
pivot_longer(-TIMESTAMP, names_to = "pit", values_to = "temp") %>%
filter(pit == "SoilT_PitA_15_Avg" |
pit == "SoilT_PitB_15_Avg" |
pit == "SoilT_PitC_15_Avg" |
pit == "SoilT_PitD_15_Avg") %>%  # want the 15cm pits
group_by(TIMESTAMP) %>%  #same as above chunk
summarize(temp = mean(temp, na.rm = TRUE))  # same as above chunk
SoilTemp_15cm_C <-  SoilTemp_15cm_C$temp
Soil15.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=SoilTemp_15cm_C), size = 0.1)
# Soil15.Plot
BaPress_kPa <- All_Data.raw$PA_1_1_1
BaPress.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=BaPress_kPa))
# BaPress.Plot
CO2_atm <- All_Data.raw$CO2_1_1_1
CO2.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=CO2_atm))
# CO2.Plot
T_canopy <- All_Data.raw$T_CANOPY_1_1_1
T_can.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=T_canopy))
# T_can.Plot
weather <- data.frame(Year, DOY, TIMESTAMP, AirTemp_C, RH_fraction, Vap_Press_kPa, Qpar, WindSpeed_m_s, WindDir_Deg, Rain_Tot, SoilTemp_5cm_C, SoilTemp_15cm_C, BaPress_kPa, CO2_atm, T_canopy)
#################
# Now we can build the actual driver file
#################
#TREES dates appear as YEARDAY, e.g. 2021001 for January 1, 2021
weather$date <- as.matrix((weather$Year*1000) + (weather$DOY))
nrows <- length(weather$date)
treesMet <- array(data=0,dim=c(nrows,18))
colnames(treesMet)<-c("Date","Time","u_ref","t_ref","d_ref","precip","Qpar","t_canopy","d_canopy",
"p_atm","CO2_atm","Ts0","Tsurf","Troot","Zw","xylemScalar","NEEobs","Ec")
treesMet <- as_tibble(treesMet)
treesMet <- treesMet %>%
mutate(Date = weather$date,
Time = hour(weather$TIMESTAMP) + minute(weather$TIMESTAMP)/60,
u_ref = if_else(weather$WindSpeed_m_s < 0.01, 0.01, weather$WindSpeed_m_s),
t_ref = weather$AirTemp_C,
d_ref = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_ref/(t_ref+243.04)),  # saturation vapor pressure
precip = weather$Rain_Tot,
Qpar = weather$Qpar,
t_canopy = weather$T_canopy,
d_canopy = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_canopy/(t_canopy + 243.04)),  # same
p_atm = weather$BaPress_kPa,
CO2_atm = weather$CO2_atm,
Ts0 = 0.5*(weather$SoilTemp_5cm_C + t_canopy),  # don't have soil surface, so use an average of 5cm and air
Tsurf = weather$SoilTemp_5cm_C,
Troot = weather$SoilTemp_15cm_C,
Zw = -10,  # unreachable water table
xylenScalar = 1,  # can be used to manipulate hydraulics. Default 1. 0.99 resets min. xylem pressures to sol water pressurem and remove memory of past droughts
NEEobs = -999,  # legacy column for use with MCMC algorithm
Ec = -999  # same
)
write_delim(treesMet, "treesMet.txt", delim = "\t")
trees[trees == "NaN"] <- NA
View(SoilHF.raw)
trees[trees == NaN] <- NA
treesMet[treesMet == NaN] <- NA
View(treesMet)
treesMet[treesMet == "NaN"] <- NA
class(treesMet$Date)
#TREES dates appear as YEARDAY, e.g. 2021001 for January 1, 2021
weather$date <- weather$Year*1000) + (weather$DOY)
#TREES dates appear as YEARDAY, e.g. 2021001 for January 1, 2021
weather$date <- weather$Year*1000 + weather$DOY
nrows <- length(weather$date)
treesMet <- array(data=0,dim=c(nrows,18))
colnames(treesMet)<-c("Date","Time","u_ref","t_ref","d_ref","precip","Qpar","t_canopy","d_canopy",
"p_atm","CO2_atm","Ts0","Tsurf","Troot","Zw","xylemScalar","NEEobs","Ec")
treesMet <- as_tibble(treesMet)
treesMet <- treesMet %>%
mutate(Date = weather$date,
Time = hour(weather$TIMESTAMP) + minute(weather$TIMESTAMP)/60,
u_ref = if_else(weather$WindSpeed_m_s < 0.01, 0.01, weather$WindSpeed_m_s),
t_ref = weather$AirTemp_C,
d_ref = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_ref/(t_ref+243.04)),  # saturation vapor pressure
precip = weather$Rain_Tot,
Qpar = weather$Qpar,
t_canopy = weather$T_canopy,
d_canopy = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_canopy/(t_canopy + 243.04)),  # same
p_atm = weather$BaPress_kPa,
CO2_atm = weather$CO2_atm,
Ts0 = 0.5*(weather$SoilTemp_5cm_C + t_canopy),  # don't have soil surface, so use an average of 5cm and air
Tsurf = weather$SoilTemp_5cm_C,
Troot = weather$SoilTemp_15cm_C,
Zw = -10,  # unreachable water table
xylenScalar = 1,  # can be used to manipulate hydraulics. Default 1. 0.99 resets min. xylem pressures to sol water pressurem and remove memory of past droughts
NEEobs = -999,  # legacy column for use with MCMC algorithm
Ec = -999  # same
)
treesMet[treesMet == "NaN"] <- NA
class(treesMet$Date)
treesMet[treesMet == "NaN"] <- NA
treesMet <- treesMet %>%
filter(Date > 2019156 & Date > 2019298)  # dates when the IRGA was on and calibrated.
#TREES dates appear as YEARDAY, e.g. 2021001 for January 1, 2021
weather$date <- weather$Year*1000 + weather$DOY
nrows <- length(weather$date)
treesMet <- array(data=0,dim=c(nrows,18))
colnames(treesMet)<-c("Date","Time","u_ref","t_ref","d_ref","precip","Qpar","t_canopy","d_canopy",
"p_atm","CO2_atm","Ts0","Tsurf","Troot","Zw","xylemScalar","NEEobs","Ec")
treesMet <- as_tibble(treesMet)
treesMet <- treesMet %>%
mutate(Date = weather$date,
Time = hour(weather$TIMESTAMP) + minute(weather$TIMESTAMP)/60,
u_ref = if_else(weather$WindSpeed_m_s < 0.01, 0.01, weather$WindSpeed_m_s),
t_ref = weather$AirTemp_C,
d_ref = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_ref/(t_ref+243.04)),  # saturation vapor pressure
precip = weather$Rain_Tot,
Qpar = weather$Qpar,
t_canopy = weather$T_canopy,
d_canopy = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_canopy/(t_canopy + 243.04)),  # same
p_atm = weather$BaPress_kPa,
CO2_atm = weather$CO2_atm,
Ts0 = 0.5*(weather$SoilTemp_5cm_C + t_canopy),  # don't have soil surface, so use an average of 5cm and air
Tsurf = weather$SoilTemp_5cm_C,
Troot = weather$SoilTemp_15cm_C,
Zw = -10,  # unreachable water table
xylenScalar = 1,  # can be used to manipulate hydraulics. Default 1. 0.99 resets min. xylem pressures to sol water pressurem and remove memory of past droughts
NEEobs = -999,  # legacy column for use with MCMC algorithm
Ec = -999  # same
)
treesMet[treesMet == "NaN"] <- NA
treesMet <- treesMet %>%
filter(Date > 2019156 & Date < 2019298)  # dates when the IRGA was on and calibrated.
treesMet <- treesMet %>%
filter(Date > 2019156 & Date < 2019246)  # dates when the IRGA was on and calibrated.
treesMet[treesMet == "NaN"] <- NA
treesMet <- treesMet %>%
filter(Date > 2019211 & Date < 2019246)  # dates with good chunks of continuous data
length(treesMet)
for (col in 1:length(treesMet)){
for (row in 1:length(treesMet[, col])){
print(paste(col,row))
}
}
length(treesMet[, 1]
)
length(treesMet[1, ]
)
length(treesMet[, 1]
)
treesMet[, 1]
length(treesMet[, 1])
length(treesMet[])
length(treesMet[, 3])
length(treesMet[1, 3])
treesMet[[1]]
length(treesMet[[1]])
for (col in 1:length(treesMet)){
for (row in 1:length(treesMet[[col]])){
print(paste(col,row))
}
}
for (col in 1:length(treesMet)){
for (row in 1:length(treesMet[[col]])){
print(paste(col,row, treesMet[row, col]))
}
}
for (col in 1:length(treesMet)){
for (row in 1:length(treesMet[[col]])){
if (is.na(treesMet[row, col])) print(paste(row, col, treesMet[row, col]))
}
}
for (i in 1:10) print(i)
for (col in 1:length(treesMet)){  # loop over columns
for (row in 1:length(treesMet[[col]])){  # loop over rows
if (is.na(treesMet[row, col])){  # detect an NA
last_finite <-  row - 1  # grab the index of the previous entry, which should be finite.
next_finite <- row  # we'll be looping over this in the while loop below
reached_end <- FALSE  # for the edge case where we reach the end without finding a finite element.
while (is.na(treesMet[next_finite, row])){  # check to see if the current element is an NA
if (next_finite == length(treesMet[[col]])){
reached_end <- TRUE
break  # if we've reached the end of the list, exit the loop
}
next_finite <- next_finite + 1  # if it is, check the next element. Otherwise, exit the loop
}
if (reached_end == TRUE){  # edge case (see above)
gap_fill <- treesMet[last_finite, col]  # fill using the last finite element
for(na_index in (last_finite + 1):length(tressMet[[col]])) treesMet[na_index, col] <- gap_fill
}
else{  # not an edge case, and there is next finite element
gap_fill <- 0.5*(treesMet[last_finite, col] + treesMet[next_finite, col])  # take the average of the last and next finite numbers
for(na_index in (last_finite + 1):(next_finite - 1)) treesMet[na_index, col] <- gap_fill
}
}
}
}
rlang::last_error()
for (col in 1:length(treesMet)){  # loop over columns
for (row in 1:length(treesMet[[col]])){  # loop over rows
if (is.na(treesMet[row, col])){  # detect an NA
last_finite <-  row - 1  # grab the index of the previous entry, which should be finite.
next_finite <- row  # we'll be looping over this in the while loop below
reached_end <- FALSE  # for the edge case where we reach the end without finding a finite element.
while (is.na(treesMet[next_finite, col])){  # check to see if the current element is an NA
if (next_finite == length(treesMet[[col]])){
reached_end <- TRUE
break  # if we've reached the end of the list, exit the loop
}
next_finite <- next_finite + 1  # if it is, check the next element. Otherwise, exit the loop
}
if (reached_end == TRUE){  # edge case (see above)
gap_fill <- treesMet[last_finite, col]  # fill using the last finite element
for(na_index in (last_finite + 1):length(tressMet[[col]])) treesMet[na_index, col] <- gap_fill
}
else{  # not an edge case, and there is next finite element
gap_fill <- 0.5*(treesMet[last_finite, col] + treesMet[next_finite, col])  # take the average of the last and next finite numbers
for(na_index in (last_finite + 1):(next_finite - 1)) treesMet[na_index, col] <- gap_fill
}
}
}
}
#TREES dates appear as YEARDAY, e.g. 2021001 for January 1, 2021
weather$date <- weather$Year*1000 + weather$DOY
nrows <- length(weather$date)
treesMet <- array(data=0,dim=c(nrows,18))
colnames(treesMet)<-c("Date","Time","u_ref","t_ref","d_ref","precip","Qpar","t_canopy","d_canopy",
"p_atm","CO2_atm","Ts0","Tsurf","Troot","Zw","xylemScalar","NEEobs","Ec")
treesMet <- as_tibble(treesMet)
treesMet <- treesMet %>%
mutate(Date = weather$date,
Time = hour(weather$TIMESTAMP) + minute(weather$TIMESTAMP)/60,
u_ref = if_else(weather$WindSpeed_m_s < 0.01, 0.01, weather$WindSpeed_m_s),
t_ref = weather$AirTemp_C,
d_ref = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_ref/(t_ref+243.04)),  # saturation vapor pressure
precip = weather$Rain_Tot,
Qpar = weather$Qpar,
t_canopy = weather$T_canopy,
d_canopy = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_canopy/(t_canopy + 243.04)),  # same
p_atm = weather$BaPress_kPa,
CO2_atm = weather$CO2_atm,
Ts0 = 0.5*(weather$SoilTemp_5cm_C + t_canopy),  # don't have soil surface, so use an average of 5cm and air
Tsurf = weather$SoilTemp_5cm_C,
Troot = weather$SoilTemp_15cm_C,
Zw = -10,  # unreachable water table
xylenScalar = 1,  # can be used to manipulate hydraulics. Default 1. 0.99 resets min. xylem pressures to sol water pressurem and remove memory of past droughts
NEEobs = -999,  # legacy column for use with MCMC algorithm
Ec = -999  # same
)
treesMet[treesMet == "NaN"] <- NA
treesMet <- treesMet %>%
filter(Date > 2019211 & Date < 2019246)  # dates with good chunks of continuous data
wherena <- which(is.na(treesMet))
wherena
wherena <- which(is.na(treesMet)==TRUE)
wherena
treesMet[which(is.na(treesMet)==TRUE)]
for (col in 1:length(treesMet)){  # loop over columns
for (row in 1:length(treesMet[[col]])){  # loop over rows
if (is.na(treesMet[row, col])){  # detect an NA
last_finite <-  row - 1  # grab the index of the previous entry, which should be finite.
next_finite <- row  # we'll be looping over this in the while loop below
reached_end <- FALSE  # for the edge case where we reach the end without finding a finite element.
while (is.na(treesMet[next_finite, col])){  # check to see if the current element is an NA
if (next_finite == length(treesMet[[col]])){
reached_end <- TRUE
break  # if we've reached the end of the list, exit the loop
}
next_finite <- next_finite + 1  # if it is, check the next element. Otherwise, exit the loop
}
if (reached_end == TRUE){  # edge case (see above)
gap_fill <- treesMet[last_finite, col]  # fill using the last finite element
for(na_index in (last_finite + 1):length(tressMet[[col]])) treesMet[na_index, col] <- gap_fill
}
else{  # not an edge case, and there is next finite element
gap_fill <- 0.5*(treesMet[last_finite, col] + treesMet[next_finite, col])  # take the average of the last and next finite numbers
for(na_index in (last_finite + 1):(next_finite - 1)) treesMet[na_index, col] <- gap_fill
}
}
}
}
which(is.na(treesMet))
treesMet <- array(data=0,dim=c(nrows,18))
colnames(treesMet)<-c("Date","Time","u_ref","t_ref","d_ref","precip","Qpar","t_canopy","d_canopy",
"p_atm","CO2_atm","Ts0","Tsurf","Troot","Zw","xylemScalar","NEEobs","Ec")
treesMet <- as_tibble(treesMet)
treesMet <- treesMet %>%
mutate(Date = weather$date,
Time = hour(weather$TIMESTAMP) + minute(weather$TIMESTAMP)/60,
u_ref = if_else(weather$WindSpeed_m_s < 0.01, 0.01, weather$WindSpeed_m_s),
t_ref = weather$AirTemp_C,
d_ref = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_ref/(t_ref+243.04)),  # saturation vapor pressure
precip = weather$Rain_Tot,
Qpar = weather$Qpar,
t_canopy = weather$T_canopy,
d_canopy = (1 - weather$RH_fraction)*0.61094*exp(17.625*t_canopy/(t_canopy + 243.04)),  # same
p_atm = weather$BaPress_kPa,
CO2_atm = weather$CO2_atm,
Ts0 = 0.5*(weather$SoilTemp_5cm_C + t_canopy),  # don't have soil surface, so use an average of 5cm and air
Tsurf = weather$SoilTemp_5cm_C,
Troot = weather$SoilTemp_15cm_C,
Zw = -10,  # unreachable water table
xylenScalar = 1,  # can be used to manipulate hydraulics. Default 1. 0.99 resets min. xylem pressures to sol water pressurem and remove memory of past droughts
NEEobs = -999,  # legacy column for use with MCMC algorithm
Ec = -999  # same
)
treesMet[treesMet == "NaN"] <- NA
treesMet <- treesMet %>%
filter(Date > 2019211 & Date < 2019246)  # dates with good chunks of continuous data
which(is.na(treesMet))
which(is.na(treesMet$CO2_atm))
CO2_na <- which(is.na(treesMet$CO2_atm))  # to check later, to make sure that it worked
for (col in 1:length(treesMet)){  # loop over columns
for (row in 1:length(treesMet[[col]])){  # loop over rows
if (is.na(treesMet[row, col])){  # detect an NA
last_finite <-  row - 1  # grab the index of the previous entry, which should be finite.
next_finite <- row  # we'll be looping over this in the while loop below
reached_end <- FALSE  # for the edge case where we reach the end without finding a finite element.
while (is.na(treesMet[next_finite, col])){  # check to see if the current element is an NA
if (next_finite == length(treesMet[[col]])){
reached_end <- TRUE
break  # if we've reached the end of the list, exit the loop
}
next_finite <- next_finite + 1  # if it is, check the next element. Otherwise, exit the loop
}
if (reached_end == TRUE){  # edge case (see above)
gap_fill <- treesMet[last_finite, col]  # fill using the last finite element
for(na_index in (last_finite + 1):length(tressMet[[col]])) treesMet[na_index, col] <- gap_fill
}
else{  # not an edge case, and there is next finite element
gap_fill <- 0.5*(treesMet[last_finite, col] + treesMet[next_finite, col])  # take the average of the last and next finite numbers
for(na_index in (last_finite + 1):(next_finite - 1)) treesMet[na_index, col] <- gap_fill
}
}
}
}
treesMet$CO2_atm[CO2_na]
CO2_na <- which(is.na(treesMet$CO2_atm))  # to check later, to make sure that it worked
Date_na <- which(is.na(treesMet$Date))
Time_na <- which(is.na(treesMet$Time))
Time_na
Date_na
Date_na == 0
Date_na == 1
Date_na == []
Date_na == integer(0)
1 == 1
length(Date_na) == 0
length(Date_na) == 1
CO2_na <- which(is.na(treesMet$CO2_atm))  # to check later, to make sure that it worked
Date_na <- which(is.na(treesMet$Date))
Time_na <- which(is.na(treesMet$Time))
stopifnot(length(Date_na) + length(Time_na) == 0)
Date_na <- [1]
Date_na <- c(1)
stopifnot(length(Date_na) + length(Time_na) == 0)
?stopifnot
assert("this equals one", 1 == 1)
CO2_na <- which(is.na(treesMet$CO2_atm))  # to check later, to make sure that it worked
Date_na <- which(is.na(treesMet$Date))
Time_na <- which(is.na(treesMet$Time))
Date_na <- c(1)
if(length(Date_na) + length(Time_na) != 0) print("You have NAs in your time columns, stopping program...")
stopifnot(length(Date_na) + length(Time_na) == 0)
CO2_na <- which(is.na(treesMet$CO2_atm))  # to check later, to make sure that it worked
Date_na <- which(is.na(treesMet$Date))
Time_na <- which(is.na(treesMet$Time))
if(length(Date_na) + length(Time_na) != 0) print("You have NAs in your time columns, stopping program...")
stopifnot(length(Date_na) + length(Time_na) == 0)
for (col in 1:length(treesMet)){  # loop over columns
for (row in 1:length(treesMet[[col]])){  # loop over rows
if (is.na(treesMet[row, col])){  # detect an NA
last_finite <-  row - 1  # grab the index of the previous entry, which should be finite.
next_finite <- row  # we'll be looping over this in the while loop below
reached_end <- FALSE  # for the edge case where we reach the end without finding a finite element.
while (is.na(treesMet[next_finite, col])){  # check to see if the current element is an NA
if (next_finite == length(treesMet[[col]])){
reached_end <- TRUE
break  # if we've reached the end of the list, exit the loop
}
next_finite <- next_finite + 1  # if it is, check the next element. Otherwise, exit the loop
}
if (reached_end == TRUE){  # edge case (see above)
gap_fill <- treesMet[last_finite, col]  # fill using the last finite element
for(na_index in (last_finite + 1):length(tressMet[[col]])) treesMet[na_index, col] <- gap_fill
}
else{  # not an edge case, and there is next finite element
gap_fill <- 0.5*(treesMet[last_finite, col] + treesMet[next_finite, col])  # take the average of the last and next finite numbers
for(na_index in (last_finite + 1):(next_finite - 1)) treesMet[na_index, col] <- gap_fill
}
}
}
}
write_delim(treesMet, "treesMet.txt", delim = "\t")
?write.csv
write.csv(All_Data.raw, "BBSF_2019_All_Weather.csv")
All_Data.raw <- read.csv("BBSF_2019_All_Weather.csv")
# Weather2013Part.csv columns:
Year = year(All_Data.raw$TIMESTAMP)
DOY = yday(All_Data.raw$TIMESTAMP)
TIMESTAMP = All_Data.raw$TIMESTAMP
AirTemp_C <- All_Data.raw$T_SONIC_1_1_1
AirTemp.Plot <- ggplot() + geom_line(mapping = aes(x=TIMESTAMP, y=AirTemp_C))
RH_fraction <- All_Data.raw$RH_1_1_1/100
Vap_Press_kPa <- RH_fraction*0.6108*exp(17.27*T/(T + 237.3))
Vap_Press.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=Vap_Press_kPa), size = 0.1)
Qpar <- All_Data.raw$PAR_dn_Avg  # incoming PAR
Qpar.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=Qpar), size=0.1)
WindSpeed_m_s <- All_Data.raw$WS_1_1_1
WS.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=WindSpeed_m_s), size = 0.1)
WindDir_Deg <- All_Data.raw$WD_1_1_1
WD.Plot <- ggplot() +
geom_point(aes(x = WindSpeed_m_s, y = WindDir_Deg, color = hour(TIMESTAMP)), size = 0.8, alpha = 0.05) +
coord_polar(theta = "y") +
scale_color_continuous(low="blue", high="red")
WD.Plot  # very cool plot
Rain_Tot <- All_Data.raw$Rain_mm_Tot
SoilTemp_5cm_C <- All_Data.raw %>%
pivot_longer(-TIMESTAMP, names_to = "pit", values_to = "temp") %>%  # longify
filter(pit == "SoilT_PitA_5_Avg" |
pit == "SoilT_PitB_5_Avg" |
pit == "SoilT_PitC_5_Avg" |
pit == "SoilT_PitD_5_Avg") %>%   # want the 5cm soil pits
group_by(TIMESTAMP) %>%  # so that we can average all four soil pits in one timestamp
summarize(temp = mean(temp, na.rm = TRUE))  # take the mean of all four soil pits at one timestamp
SoilTemp_5cm_C <- SoilTemp_5cm_C$temp
Soil5.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=SoilTemp_5cm_C), size = 0.1)
SoilTemp_15cm_C <- All_Data.raw %>%
pivot_longer(-TIMESTAMP, names_to = "pit", values_to = "temp") %>%
filter(pit == "SoilT_PitA_15_Avg" |
pit == "SoilT_PitB_15_Avg" |
pit == "SoilT_PitC_15_Avg" |
pit == "SoilT_PitD_15_Avg") %>%  # want the 15cm pits
group_by(TIMESTAMP) %>%  #same as above chunk
summarize(temp = mean(temp, na.rm = TRUE))  # same as above chunk
SoilTemp_15cm_C <-  SoilTemp_15cm_C$temp
Soil15.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=SoilTemp_15cm_C), size = 0.1)
BaPress_kPa <- All_Data.raw$PA_1_1_1
BaPress.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=BaPress_kPa))
CO2_atm <- All_Data.raw$CO2_1_1_1
CO2.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=CO2_atm))
T_canopy <- All_Data.raw$T_CANOPY_1_1_1
T_can.Plot <- ggplot() + geom_point(aes(x=TIMESTAMP, y=T_canopy))
weather <- data.frame(Year, DOY, TIMESTAMP, AirTemp_C, RH_fraction, Vap_Press_kPa, Qpar, WindSpeed_m_s, WindDir_Deg, Rain_Tot, SoilTemp_5cm_C, SoilTemp_15cm_C, BaPress_kPa, CO2_atm, T_canopy)
for (col in treesMet) print(class(col))
ggplot(data = treesMet) +
geom_point(aes(x=Time, y=CO2_atm), size=0.3)  # compress all data into one day and plot
ggplot(data = treesMet) +
geom_point(aes(x=Time, y=p_atm), size=0.3)  # compress all data into one day and plot
ggplot(data = treesMet) +
geom_point(aes(x=Time, y=d_ref), size=0.3)  # compress all data into one day and plot
ggplot(data = treesMet) +
geom_point(aes(x=Time, y=Qpar), size=0.3)  # compress all data into one day and plot
